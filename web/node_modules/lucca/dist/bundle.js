/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory(root.maquette = {});
    }
}(this, function (exports) {
    'use strict';
    // Comment that is displayed in the API documentation for the maquette module:
    /**
 * Welcome to the API documentation of the **maquette** library.
 *
 * [[http://maquettejs.org/|To the maquette homepage]]
 */
    Object.defineProperty(exports, '__esModule', { value: true });
    var NAMESPACE_W3 = 'http://www.w3.org/';
    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    // Utilities
    var emptyArray = [];
    var extend = function (base, overrides) {
        var result = {};
        Object.keys(base).forEach(function (key) {
            result[key] = base[key];
        });
        if (overrides) {
            Object.keys(overrides).forEach(function (key) {
                result[key] = overrides[key];
            });
        }
        return result;
    };
    // Hyperscript helper functions
    var same = function (vnode1, vnode2) {
        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {
            return false;
        }
        if (vnode1.properties && vnode2.properties) {
            if (vnode1.properties.key !== vnode2.properties.key) {
                return false;
            }
            return vnode1.properties.bind === vnode2.properties.bind;
        }
        return !vnode1.properties && !vnode2.properties;
    };
    var toTextVNode = function (data) {
        return {
            vnodeSelector: '',
            properties: undefined,
            children: undefined,
            text: data.toString(),
            domNode: null
        };
    };
    var appendChildren = function (parentSelector, insertions, main) {
        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {
            var item = insertions[i];
            if (Array.isArray(item)) {
                appendChildren(parentSelector, item, main);
            } else {
                if (item !== null && item !== undefined) {
                    if (!item.hasOwnProperty('vnodeSelector')) {
                        item = toTextVNode(item);
                    }
                    main.push(item);
                }
            }
        }
    };
    // Render helper functions
    var missingTransition = function () {
        throw new Error('Provide a transitions object to the projectionOptions to do animations');
    };
    var DEFAULT_PROJECTION_OPTIONS = {
        namespace: undefined,
        eventHandlerInterceptor: undefined,
        styleApplyer: function (domNode, styleName, value) {
            // Provides a hook to add vendor prefixes for browsers that still need it.
            domNode.style[styleName] = value;
        },
        transitions: {
            enter: missingTransition,
            exit: missingTransition
        }
    };
    var applyDefaultProjectionOptions = function (projectorOptions) {
        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);
    };
    var checkStyleValue = function (styleValue) {
        if (typeof styleValue !== 'string') {
            throw new Error('Style values must be strings');
        }
    };
    var setProperties = function (domNode, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        var _loop_1 = function (i) {
            var propName = propNames[i];
            /* tslint:disable:no-var-keyword: edge case */
            var propValue = properties[propName];
            /* tslint:enable:no-var-keyword */
            if (propName === 'className') {
                throw new Error('Property "className" is not supported, use "class".');
            } else if (propName === 'class') {
                propValue.split(/\s+/).forEach(function (token) {
                    return domNode.classList.add(token);
                });
            } else if (propName === 'classes') {
                // object with string keys and boolean values
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    if (propValue[className]) {
                        domNode.classList.add(className);
                    }
                }
            } else if (propName === 'styles') {
                // object with string keys and string (!) values
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var styleValue = propValue[styleName];
                    if (styleValue) {
                        checkStyleValue(styleValue);
                        projectionOptions.styleApplyer(domNode, styleName, styleValue);
                    }
                }
            } else if (propName !== 'key' && propValue !== null && propValue !== undefined) {
                var type = typeof propValue;
                if (type === 'function') {
                    if (propName.lastIndexOf('on', 0) === 0) {
                        if (eventHandlerInterceptor) {
                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers
                        }
                        if (propName === 'oninput') {
                            (function () {
                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput
                                var oldPropValue = propValue;
                                propValue = function (evt) {
                                    oldPropValue.apply(this, [evt]);
                                    evt.target['oninput-value'] = evt.target.value;    // may be HTMLTextAreaElement as well
                                };
                            }());
                        }
                        domNode[propName] = propValue;
                    }
                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {
                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                    } else {
                        domNode.setAttribute(propName, propValue);
                    }
                } else {
                    domNode[propName] = propValue;
                }
            }
        };
        for (var i = 0; i < propCount; i++) {
            _loop_1(i);
        }
    };
    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var propertiesUpdated = false;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        for (var i = 0; i < propCount; i++) {
            var propName = propNames[i];
            // assuming that properties will be nullified instead of missing is by design
            var propValue = properties[propName];
            var previousValue = previousProperties[propName];
            if (propName === 'class') {
                if (previousValue !== propValue) {
                    throw new Error('"class" property may not be updated. Use the "classes" property for conditional css classes.');
                }
            } else if (propName === 'classes') {
                var classList = domNode.classList;
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    var on = !!propValue[className];
                    var previousOn = !!previousValue[className];
                    if (on === previousOn) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (on) {
                        classList.add(className);
                    } else {
                        classList.remove(className);
                    }
                }
            } else if (propName === 'styles') {
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var newStyleValue = propValue[styleName];
                    var oldStyleValue = previousValue[styleName];
                    if (newStyleValue === oldStyleValue) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (newStyleValue) {
                        checkStyleValue(newStyleValue);
                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);
                    } else {
                        projectionOptions.styleApplyer(domNode, styleName, '');
                    }
                }
            } else {
                if (!propValue && typeof previousValue === 'string') {
                    propValue = '';
                }
                if (propName === 'value') {
                    var domValue = domNode[propName];
                    if (domValue !== propValue    // The 'value' in the DOM tree !== newValue
&& (domNode['oninput-value'] ? domValue === domNode['oninput-value']    // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput
 : propValue !== previousValue    // Only update the value if the vdom changed
)) {
                        domNode[propName] = propValue;
                        // Reset the value, even if the virtual DOM did not change
                        domNode['oninput-value'] = undefined;
                    }
                    // else do not update the domNode, otherwise the cursor position would be changed
                    if (propValue !== previousValue) {
                        propertiesUpdated = true;
                    }
                } else if (propValue !== previousValue) {
                    var type = typeof propValue;
                    if (type === 'function') {
                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');
                    }
                    if (type === 'string' && propName !== 'innerHTML') {
                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                        } else if (propName === 'role' && propValue === '') {
                            domNode.removeAttribute(propName);
                        } else {
                            domNode.setAttribute(propName, propValue);
                        }
                    } else {
                        if (domNode[propName] !== propValue) {
                            domNode[propName] = propValue;
                        }
                    }
                    propertiesUpdated = true;
                }
            }
        }
        return propertiesUpdated;
    };
    var findIndexOfChild = function (children, sameAs, start) {
        if (sameAs.vnodeSelector !== '') {
            // Never scan for text-nodes
            for (var i = start; i < children.length; i++) {
                if (same(children[i], sameAs)) {
                    return i;
                }
            }
        }
        return -1;
    };
    var nodeAdded = function (vNode, transitions) {
        if (vNode.properties) {
            var enterAnimation = vNode.properties.enterAnimation;
            if (enterAnimation) {
                if (typeof enterAnimation === 'function') {
                    enterAnimation(vNode.domNode, vNode.properties);
                } else {
                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);
                }
            }
        }
    };
    var nodeToRemove = function (vNode, transitions) {
        var domNode = vNode.domNode;
        if (vNode.properties) {
            var exitAnimation = vNode.properties.exitAnimation;
            if (exitAnimation) {
                domNode.style.pointerEvents = 'none';
                var removeDomNode = function () {
                    if (domNode.parentNode) {
                        domNode.parentNode.removeChild(domNode);
                    }
                };
                if (typeof exitAnimation === 'function') {
                    exitAnimation(domNode, removeDomNode, vNode.properties);
                    return;
                } else {
                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);
                    return;
                }
            }
        }
        if (domNode.parentNode) {
            domNode.parentNode.removeChild(domNode);
        }
    };
    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {
        var childNode = childNodes[indexToCheck];
        if (childNode.vnodeSelector === '') {
            return;    // Text nodes need not be distinguishable
        }
        var properties = childNode.properties;
        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;
        if (!key) {
            for (var i = 0; i < childNodes.length; i++) {
                if (i !== indexToCheck) {
                    var node = childNodes[i];
                    if (same(node, childNode)) {
                        if (operation === 'added') {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');
                        } else {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');
                        }
                    }
                }
            }
        }
    };
    var createDom;
    var updateDom;
    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {
        if (oldChildren === newChildren) {
            return false;
        }
        oldChildren = oldChildren || emptyArray;
        newChildren = newChildren || emptyArray;
        var oldChildrenLength = oldChildren.length;
        var newChildrenLength = newChildren.length;
        var transitions = projectionOptions.transitions;
        var oldIndex = 0;
        var newIndex = 0;
        var i;
        var textUpdated = false;
        while (newIndex < newChildrenLength) {
            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;
            var newChild = newChildren[newIndex];
            if (oldChild !== undefined && same(oldChild, newChild)) {
                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;
                oldIndex++;
            } else {
                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);
                if (findOldIndex >= 0) {
                    // Remove preceding missing children
                    for (i = oldIndex; i < findOldIndex; i++) {
                        nodeToRemove(oldChildren[i], transitions);
                        checkDistinguishable(oldChildren, i, vnode, 'removed');
                    }
                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;
                    oldIndex = findOldIndex + 1;
                } else {
                    // New child
                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);
                    nodeAdded(newChild, transitions);
                    checkDistinguishable(newChildren, newIndex, vnode, 'added');
                }
            }
            newIndex++;
        }
        if (oldChildrenLength > oldIndex) {
            // Remove child fragments
            for (i = oldIndex; i < oldChildrenLength; i++) {
                nodeToRemove(oldChildren[i], transitions);
                checkDistinguishable(oldChildren, i, vnode, 'removed');
            }
        }
        return textUpdated;
    };
    var addChildren = function (domNode, children, projectionOptions) {
        if (!children) {
            return;
        }
        for (var i = 0; i < children.length; i++) {
            createDom(children[i], domNode, undefined, projectionOptions);
        }
    };
    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {
        addChildren(domNode, vnode.children, projectionOptions);
        // children before properties, needed for value property of <select>.
        if (vnode.text) {
            domNode.textContent = vnode.text;
        }
        setProperties(domNode, vnode.properties, projectionOptions);
        if (vnode.properties && vnode.properties.afterCreate) {
            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [
                domNode,
                projectionOptions,
                vnode.vnodeSelector,
                vnode.properties,
                vnode.children
            ]);
        }
    };
    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {
        var domNode, i, c, start = 0, type, found;
        var vnodeSelector = vnode.vnodeSelector;
        var doc = parentNode.ownerDocument;
        if (vnodeSelector === '') {
            domNode = vnode.domNode = doc.createTextNode(vnode.text);
            if (insertBefore !== undefined) {
                parentNode.insertBefore(domNode, insertBefore);
            } else {
                parentNode.appendChild(domNode);
            }
        } else {
            for (i = 0; i <= vnodeSelector.length; ++i) {
                c = vnodeSelector.charAt(i);
                if (i === vnodeSelector.length || c === '.' || c === '#') {
                    type = vnodeSelector.charAt(start - 1);
                    found = vnodeSelector.slice(start, i);
                    if (type === '.') {
                        domNode.classList.add(found);
                    } else if (type === '#') {
                        domNode.id = found;
                    } else {
                        if (found === 'svg') {
                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
                        }
                        if (projectionOptions.namespace !== undefined) {
                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);
                        } else {
                            domNode = vnode.domNode = vnode.domNode || doc.createElement(found);
                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {
                                // IE8 and older don't support setting input type after the DOM Node has been added to the document
                                domNode.setAttribute('type', vnode.properties.type);
                            }
                        }
                        if (insertBefore !== undefined) {
                            parentNode.insertBefore(domNode, insertBefore);
                        } else if (domNode.parentNode !== parentNode) {
                            parentNode.appendChild(domNode);
                        }
                    }
                    start = i + 1;
                }
            }
            initPropertiesAndChildren(domNode, vnode, projectionOptions);
        }
    };
    updateDom = function (previous, vnode, projectionOptions) {
        var domNode = previous.domNode;
        var textUpdated = false;
        if (previous === vnode) {
            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette
        }
        var updated = false;
        if (vnode.vnodeSelector === '') {
            if (vnode.text !== previous.text) {
                var newVNode = domNode.ownerDocument.createTextNode(vnode.text);
                domNode.parentNode.replaceChild(newVNode, domNode);
                vnode.domNode = newVNode;
                textUpdated = true;
                return textUpdated;
            }
        } else {
            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {
                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
            }
            if (previous.text !== vnode.text) {
                updated = true;
                if (vnode.text === undefined) {
                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably
                } else {
                    domNode.textContent = vnode.text;
                }
            }
            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;
            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;
            if (vnode.properties && vnode.properties.afterUpdate) {
                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [
                    domNode,
                    projectionOptions,
                    vnode.vnodeSelector,
                    vnode.properties,
                    vnode.children
                ]);
            }
        }
        if (updated && vnode.properties && vnode.properties.updateAnimation) {
            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);
        }
        vnode.domNode = previous.domNode;
        return textUpdated;
    };
    var createProjection = function (vnode, projectionOptions) {
        return {
            update: function (updatedVnode) {
                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {
                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');
                }
                updateDom(vnode, updatedVnode, projectionOptions);
                vnode = updatedVnode;
            },
            domNode: vnode.domNode
        };
    };
    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.
    exports.h = function (selector) {
        var properties = arguments[1];
        if (typeof selector !== 'string') {
            throw new Error();
        }
        var childIndex = 1;
        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {
            childIndex = 2;
        } else {
            // Optional properties argument was omitted
            properties = undefined;
        }
        var text;
        var children;
        var argsLength = arguments.length;
        // Recognize a common special case where there is only a single text node
        if (argsLength === childIndex + 1) {
            var onlyChild = arguments[childIndex];
            if (typeof onlyChild === 'string') {
                text = onlyChild;
            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {
                text = onlyChild[0];
            }
        }
        if (text === undefined) {
            children = [];
            for (; childIndex < argsLength; childIndex++) {
                var child = arguments[childIndex];
                if (child === null || child === undefined) {
                } else if (Array.isArray(child)) {
                    appendChildren(selector, child, children);
                } else if (child.hasOwnProperty('vnodeSelector')) {
                    children.push(child);
                } else {
                    children.push(toTextVNode(child));
                }
            }
        }
        return {
            vnodeSelector: selector,
            properties: properties,
            children: children,
            text: text === '' ? undefined : text,
            domNode: null
        };
    };
    /**
 * Contains simple low-level utility functions to manipulate the real DOM.
 */
    exports.dom = {
        /**
     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in
     * its [[Projection.domNode|domNode]] property.
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection.
     * @returns The [[Projection]] which also contains the DOM Node that was created.
     */
        create: function (vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, document.createElement('div'), undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Appends a new child node to the DOM which is generated from a [[VNode]].
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param parentNode - The parent node for the new child node.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the [[Projection]].
     * @returns The [[Projection]] that was created.
     */
        append: function (parentNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, parentNode, undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Inserts a new DOM node which is generated from a [[VNode]].
     * This is a low-level method. Users wil typically use a [[Projector]] instead.
     * @param beforeNode - The node that the DOM Node is inserted before.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.
     * NOTE: [[VNode]] objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
     * @returns The [[Projection]] that was created.
     */
        insertBefore: function (beforeNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.
     * This means that the virtual DOM and the real DOM will have one overlapping element.
     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.
     * This is a low-level method. Users wil typically use a [[Projector]] instead.
     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects
     * may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
     * @returns The [[Projection]] that was created.
     */
        merge: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            vnode.domNode = element;
            initPropertiesAndChildren(element, vnode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Replaces an existing DOM node with a node generated from a [[VNode]].
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param element - The node for the [[VNode]] to replace.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the [[Projection]].
     * @returns The [[Projection]] that was created.
     */
        replace: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, element.parentNode, element, projectionOptions);
            element.parentNode.removeChild(element);
            return createProjection(vnode, projectionOptions);
        }
    };
    /**
 * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.
 * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.
 * For more information, see [[CalculationCache]].
 *
 * @param <Result> The type of the value that is cached.
 */
    exports.createCache = function () {
        var cachedInputs;
        var cachedOutcome;
        return {
            invalidate: function () {
                cachedOutcome = undefined;
                cachedInputs = undefined;
            },
            result: function (inputs, calculation) {
                if (cachedInputs) {
                    for (var i = 0; i < inputs.length; i++) {
                        if (cachedInputs[i] !== inputs[i]) {
                            cachedOutcome = undefined;
                        }
                    }
                }
                if (!cachedOutcome) {
                    cachedOutcome = calculation();
                    cachedInputs = inputs;
                }
                return cachedOutcome;
            }
        };
    };
    /**
 * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.
 * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.
 *
 * @param <Source>       The type of source items. A database-record for instance.
 * @param <Target>       The type of target items. A [[Component]] for instance.
 * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.
 * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical
 *                       to the `callback` argument in `Array.map(callback)`.
 * @param updateResult   `function(source, target, index)` that updates a result to an updated source.
 */
    exports.createMapping = function (getSourceKey, createResult, updateResult) {
        var keys = [];
        var results = [];
        return {
            results: results,
            map: function (newSources) {
                var newKeys = newSources.map(getSourceKey);
                var oldTargets = results.slice();
                var oldIndex = 0;
                for (var i = 0; i < newSources.length; i++) {
                    var source = newSources[i];
                    var sourceKey = newKeys[i];
                    if (sourceKey === keys[oldIndex]) {
                        results[i] = oldTargets[oldIndex];
                        updateResult(source, oldTargets[oldIndex], i);
                        oldIndex++;
                    } else {
                        var found = false;
                        for (var j = 1; j < keys.length + 1; j++) {
                            var searchIndex = (oldIndex + j) % keys.length;
                            if (keys[searchIndex] === sourceKey) {
                                results[i] = oldTargets[searchIndex];
                                updateResult(newSources[i], oldTargets[searchIndex], i);
                                oldIndex = searchIndex + 1;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            results[i] = createResult(source, i);
                        }
                    }
                }
                results.length = newSources.length;
                keys = newKeys;
            }
        };
    };
    /**
 * Creates a [[Projector]] instance using the provided projectionOptions.
 *
 * For more information, see [[Projector]].
 *
 * @param projectorOptions   Options that influence how the DOM is rendered and updated.
 */
    exports.createProjector = function (projectorOptions) {
        var projector;
        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);
        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {
            return function () {
                // intercept function calls (event handlers) to do a render afterwards.
                projector.scheduleRender();
                return eventHandler.apply(properties.bind || this, arguments);
            };
        };
        var renderCompleted = true;
        var scheduled;
        var stopped = false;
        var projections = [];
        var renderFunctions = [];
        // matches the projections array
        var doRender = function () {
            scheduled = undefined;
            if (!renderCompleted) {
                return;    // The last render threw an error, it should be logged in the browser console.
            }
            renderCompleted = false;
            for (var i = 0; i < projections.length; i++) {
                var updatedVnode = renderFunctions[i]();
                projections[i].update(updatedVnode);
            }
            renderCompleted = true;
        };
        projector = {
            renderNow: doRender,
            scheduleRender: function () {
                if (!scheduled && !stopped) {
                    scheduled = requestAnimationFrame(doRender);
                }
            },
            stop: function () {
                if (scheduled) {
                    cancelAnimationFrame(scheduled);
                    scheduled = undefined;
                }
                stopped = true;
            },
            resume: function () {
                stopped = false;
                renderCompleted = true;
                projector.scheduleRender();
            },
            append: function (parentNode, renderMaquetteFunction) {
                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            insertBefore: function (beforeNode, renderMaquetteFunction) {
                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            merge: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            replace: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            detach: function (renderMaquetteFunction) {
                for (var i = 0; i < renderFunctions.length; i++) {
                    if (renderFunctions[i] === renderMaquetteFunction) {
                        renderFunctions.splice(i, 1);
                        return projections.splice(i, 1)[0];
                    }
                }
                throw new Error('renderMaquetteFunction was not found');
            }
        };
        return projector;
    };
}));
//# sourceMappingURL=maquette.js.map


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const VNodeApp_1 = __webpack_require__(2);
window.lucca = new VNodeApp_1.VNodeApp();


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = __webpack_require__(3);
const VNodeView_1 = __webpack_require__(5);
const BaseReceiver_1 = __webpack_require__(6);
const ActionDispatcher_1 = __webpack_require__(7);
const ActionQueue_1 = __webpack_require__(8);
const VNodeRenderer_1 = __webpack_require__(9);
class VNodeApp {
    constructor() {
        this.models = new Map();
        this.views = new Map();
        this.recv = new Map();
        this.renderer = new VNodeRenderer_1.VNodeRenderer();
        this.actionQueue = new ActionQueue_1.ActionQueue();
        this.actionDispatcher = new ActionDispatcher_1.ActionDispatcher(this.actionQueue.queue.bind(this.actionQueue));
        this.htmlProvider = this.renderer.getViewableProvider();
        this.viewInjector = this.renderer.getViewInjector(this.views);
    }
    model(name) {
        let m = new BaseModel_1.BaseModel(name);
        this.models.set(name, m);
        return m;
    }
    view(name) {
        let v = new VNodeView_1.VNodeView(name, this.htmlProvider, this.viewInjector, this.actionDispatcher);
        this.views.set(name, v);
        return v;
    }
    vm(name) {
        let r = new BaseReceiver_1.BaseReceiver(name);
        this.recv.set(name, r);
        return r;
    }
    tick() {
        window.requestAnimationFrame.call(window, this.tick.bind(this));
        this.actionTick();
    }
    init(domNode) {
        this.recv.forEach((r) => { r.init(this.models, this.views); });
        this.renderer.mount(domNode, this.getAppRenderTree.bind(this));
    }
    actionTick() {
        let nextAction = this.actionQueue.dequeue();
        if (nextAction) {
            this.recv.forEach((r) => {
                r.triggerStateChange(nextAction);
            });
        }
    }
    getAppRenderTree() {
        let receivers = Array.from(this.recv.values());
        return this.renderer.stitch(() => {
            return receivers.map((r) => {
                return r.getRenderTree();
            });
        });
    }
}
exports.VNodeApp = VNodeApp;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const HttpService_1 = __webpack_require__(4);
class BaseModel {
    constructor(name) {
        this.name = name;
        this.data = {};
        this.handlers = new Map();
        this.http = new HttpService_1.HttpService();
        this.isLoading = false;
    }
    define(data) {
        this.data = data;
        return this;
    }
    get(url) {
        this.isLoading = true;
        this.http.get(url, (res) => {
            this.data = res;
            this.isLoading = false;
        });
        return this;
    }
    getData() {
        return this.data;
    }
    handle(stateName, handler) {
        this.handlers.set(stateName, handler);
        return this;
    }
    save() {
        return (() => false);
    }
    refresh() { }
    handleStateChange(stateName, evt) {
        let handler = this.handlers.get(stateName);
        if (handler) {
            handler.apply(this, [this.data, evt]);
            return;
        }
        console.error(`state ${stateName} not handled`);
    }
}
exports.BaseModel = BaseModel;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class HttpService {
    constructor() { }
    get(url, callback) {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "json";
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                callback.call(null, xhr);
            }
        };
        xhr.send();
    }
    post() {
    }
}
exports.HttpService = HttpService;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class VNodeView {
    constructor(name, h, v, a) {
        this.name = name;
        this.htmlProvider = h;
        this.viewProvider = v;
        this.actionDispatcher = a;
        this.actionLookup = new Map();
    }
    define(viewConstructor) {
        this.viewConstructor = viewConstructor;
        return this;
    }
    render(model) {
        return this.viewConstructor(this.htmlProvider, this.viewProvider, model.getData(), this.actionLookup);
    }
    registerActions(...actionNames) {
        for (var i = 0; i < actionNames.length; i++) {
            let actionName = actionNames[i];
            this.actionLookup[actionName] = this.actionDispatcher.dispatch.bind(this.actionDispatcher, actionName);
        }
        return this;
    }
}
exports.VNodeView = VNodeView;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BaseReceiver {
    constructor(name) {
        this.name = name;
    }
    init(modelLookup, viewLookup) {
        let m = modelLookup.get(this._modelName);
        let v = viewLookup.get(this._viewName);
        if (m == null) {
            throw new Error(`model ${this._modelName} is null`);
        }
        if (v == null) {
            throw new Error(`view ${this._viewName} is null`);
        }
        this._model = m;
        this._view = v;
    }
    model(name) {
        this._modelName = name;
        return this;
    }
    view(name) {
        this._viewName = name;
        return this;
    }
    accept(routes) {
        this.actionStateRoutes = routes;
        return this;
    }
    triggerStateChange(action) {
        if (this._model == null) {
            throw new Error("model cannot be null");
        }
        if (this.doesAcceptAction(action)) {
            let actionName = action[0];
            this._model.handleStateChange(this.actionStateRoutes[actionName], action[1]);
        }
    }
    getRenderTree() {
        if (this._view == null) {
            throw new Error("view cannot be null");
        }
        return this._view.render(this._model);
    }
    doesAcceptAction(action) {
        if (this.actionStateRoutes == null) {
            throw new Error("action routes cannot be null");
        }
        let actionName = action[0];
        return this.actionStateRoutes.hasOwnProperty(actionName);
    }
}
exports.BaseReceiver = BaseReceiver;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ActionDispatcher {
    constructor(queueAction) {
        this.queueAction = queueAction;
    }
    dispatch(actionName, e) {
        this.queueAction([actionName, e]);
    }
}
exports.ActionDispatcher = ActionDispatcher;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ActionQueue {
    constructor() {
        this.members = [];
    }
    queue(action) {
        this.members.push(action);
        return this.members.length;
    }
    dequeue() {
        if (this.members.length > 0) {
            return this.members.shift();
        }
        console.info('Action Queue is empty');
    }
    peek() {
        return this.members[0];
    }
}
exports.ActionQueue = ActionQueue;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const maquette_1 = __webpack_require__(0);
const VNodeProvider_1 = __webpack_require__(10);
class VNodeRenderer {
    constructor() {
        this.projector = maquette_1.createProjector();
    }
    stitch(renderChildren) {
        return maquette_1.h('div.appContainer', {}, renderChildren());
    }
    mount(domNode, renderFn) {
        this.projector.append(domNode, renderFn);
    }
    getViewableProvider() {
        return new VNodeProvider_1.VNodeProvider();
    }
    getViewInjector(lookup) {
        return (name, data) => {
            let view = lookup.get(name);
            if (view) {
                return view.render(data);
            }
        };
    }
}
exports.VNodeRenderer = VNodeRenderer;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const maquette_1 = __webpack_require__(0);
class VNodeProvider {
    constructor() {
        this.tml = this.provide;
    }
    provide(selector, attr, contents) {
        return maquette_1.h(selector, attr, contents);
    }
    forEach(data, iteratorFn) {
        if (Array.isArray(data)) {
            return data.map(iteratorFn);
        }
        throw new Error("data must be iterable to use forEach");
    }
}
exports.VNodeProvider = VNodeProvider;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODlmZTI0NDA4NGI5ZjEyMzQ4OGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcXVldHRlL2Rpc3QvbWFxdWV0dGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9mYWNhZGUvVk5vZGVBcHAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL0Jhc2VNb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbmV0L0h0dHBTZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy92aWV3L1ZOb2RlVmlldy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYWN0aW9uL0Jhc2VSZWNlaXZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYWN0aW9uL0FjdGlvbkRpc3BhdGNoZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FjdGlvbi9BY3Rpb25RdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL1ZOb2RlUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlci9WTm9kZVByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFB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ekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVNLE9BQU8sQ0FBQyxJQUFVLEVBQUUsVUFBdUI7UUFDOUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztJQUM1RCxDQUFDO0NBQ0o7QUFiRCxzQ0FhQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA4OWZlMjQ0MDg0YjlmMTIzNDg4ZSIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBDb21tb25KU1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICBmYWN0b3J5KHJvb3QubWFxdWV0dGUgPSB7fSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBDb21tZW50IHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBBUEkgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIG1hcXVldHRlIG1vZHVsZTpcbiAgICAvKipcbiAqIFdlbGNvbWUgdG8gdGhlIEFQSSBkb2N1bWVudGF0aW9uIG9mIHRoZSAqKm1hcXVldHRlKiogbGlicmFyeS5cbiAqXG4gKiBbW2h0dHA6Ly9tYXF1ZXR0ZWpzLm9yZy98VG8gdGhlIG1hcXVldHRlIGhvbWVwYWdlXV1cbiAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgdmFyIE5BTUVTUEFDRV9XMyA9ICdodHRwOi8vd3d3LnczLm9yZy8nO1xuICAgIHZhciBOQU1FU1BBQ0VfU1ZHID0gTkFNRVNQQUNFX1czICsgJzIwMDAvc3ZnJztcbiAgICB2YXIgTkFNRVNQQUNFX1hMSU5LID0gTkFNRVNQQUNFX1czICsgJzE5OTkveGxpbmsnO1xuICAgIC8vIFV0aWxpdGllc1xuICAgIHZhciBlbXB0eUFycmF5ID0gW107XG4gICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChiYXNlLCBvdmVycmlkZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gYmFzZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMob3ZlcnJpZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG92ZXJyaWRlc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIEh5cGVyc2NyaXB0IGhlbHBlciBmdW5jdGlvbnNcbiAgICB2YXIgc2FtZSA9IGZ1bmN0aW9uICh2bm9kZTEsIHZub2RlMikge1xuICAgICAgICBpZiAodm5vZGUxLnZub2RlU2VsZWN0b3IgIT09IHZub2RlMi52bm9kZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlMS5wcm9wZXJ0aWVzICYmIHZub2RlMi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAodm5vZGUxLnByb3BlcnRpZXMua2V5ICE9PSB2bm9kZTIucHJvcGVydGllcy5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLnByb3BlcnRpZXMuYmluZCA9PT0gdm5vZGUyLnByb3BlcnRpZXMuYmluZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXZub2RlMS5wcm9wZXJ0aWVzICYmICF2bm9kZTIucHJvcGVydGllcztcbiAgICB9O1xuICAgIHZhciB0b1RleHRWTm9kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2bm9kZVNlbGVjdG9yOiAnJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBkb21Ob2RlOiBudWxsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYXBwZW5kQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50U2VsZWN0b3IsIGluc2VydGlvbnMsIG1haW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGluc2VydGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKHBhcmVudFNlbGVjdG9yLCBpdGVtLCBtYWluKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5oYXNPd25Qcm9wZXJ0eSgndm5vZGVTZWxlY3RvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gdG9UZXh0Vk5vZGUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFpbi5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUmVuZGVyIGhlbHBlciBmdW5jdGlvbnNcbiAgICB2YXIgbWlzc2luZ1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZSBhIHRyYW5zaXRpb25zIG9iamVjdCB0byB0aGUgcHJvamVjdGlvbk9wdGlvbnMgdG8gZG8gYW5pbWF0aW9ucycpO1xuICAgIH07XG4gICAgdmFyIERFRkFVTFRfUFJPSkVDVElPTl9PUFRJT05TID0ge1xuICAgICAgICBuYW1lc3BhY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgZXZlbnRIYW5kbGVySW50ZXJjZXB0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgc3R5bGVBcHBseWVyOiBmdW5jdGlvbiAoZG9tTm9kZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gUHJvdmlkZXMgYSBob29rIHRvIGFkZCB2ZW5kb3IgcHJlZml4ZXMgZm9yIGJyb3dzZXJzIHRoYXQgc3RpbGwgbmVlZCBpdC5cbiAgICAgICAgICAgIGRvbU5vZGUuc3R5bGVbc3R5bGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2l0aW9uczoge1xuICAgICAgICAgICAgZW50ZXI6IG1pc3NpbmdUcmFuc2l0aW9uLFxuICAgICAgICAgICAgZXhpdDogbWlzc2luZ1RyYW5zaXRpb25cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zID0gZnVuY3Rpb24gKHByb2plY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChERUZBVUxUX1BST0pFQ1RJT05fT1BUSU9OUywgcHJvamVjdG9yT3B0aW9ucyk7XG4gICAgfTtcbiAgICB2YXIgY2hlY2tTdHlsZVZhbHVlID0gZnVuY3Rpb24gKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHlsZSB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRvbU5vZGUsIHByb3BlcnRpZXMsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJJbnRlcmNlcHRvciA9IHByb2plY3Rpb25PcHRpb25zLmV2ZW50SGFuZGxlckludGVyY2VwdG9yO1xuICAgICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gICAgICAgIHZhciBwcm9wQ291bnQgPSBwcm9wTmFtZXMubGVuZ3RoO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wTmFtZXNbaV07XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby12YXIta2V5d29yZDogZWRnZSBjYXNlICovXG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLXZhci1rZXl3b3JkICovXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdjbGFzc05hbWUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImNsYXNzTmFtZVwiIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSBcImNsYXNzXCIuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGUuY2xhc3NMaXN0LmFkZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnY2xhc3NlcycpIHtcbiAgICAgICAgICAgICAgICAvLyBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgYm9vbGVhbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUNvdW50ID0gY2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc05hbWVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcFZhbHVlW2NsYXNzTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAvLyBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBhbmQgc3RyaW5nICghKSB2YWx1ZXNcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlQ291bnQgPSBzdHlsZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0eWxlQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gc3R5bGVOYW1lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlVmFsdWUgPSBwcm9wVmFsdWVbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU3R5bGVWYWx1ZShzdHlsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zLnN0eWxlQXBwbHllcihkb21Ob2RlLCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSAhPT0gJ2tleScgJiYgcHJvcFZhbHVlICE9PSBudWxsICYmIHByb3BWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZS5sYXN0SW5kZXhPZignb24nLCAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlckludGVyY2VwdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gZXZlbnRIYW5kbGVySW50ZXJjZXB0b3IocHJvcE5hbWUsIHByb3BWYWx1ZSwgZG9tTm9kZSwgcHJvcGVydGllcyk7ICAgIC8vIGludGVyY2VwdCBldmVudGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdvbmlucHV0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29yZCB0aGUgZXZ0LnRhcmdldC52YWx1ZSwgYmVjYXVzZSBJRSBhbmQgRWRnZSBzb21ldGltZXMgZG8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYmV0d2VlbiBjaGFuZ2luZyB2YWx1ZSBhbmQgcnVubmluZyBvbmlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRQcm9wVmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFByb3BWYWx1ZS5hcHBseSh0aGlzLCBbZXZ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldnQudGFyZ2V0WydvbmlucHV0LXZhbHVlJ10gPSBldnQudGFyZ2V0LnZhbHVlOyAgICAvLyBtYXkgYmUgSFRNTFRleHRBcmVhRWxlbWVudCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBwcm9wTmFtZSAhPT0gJ3ZhbHVlJyAmJiBwcm9wTmFtZSAhPT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb25PcHRpb25zLm5hbWVzcGFjZSA9PT0gTkFNRVNQQUNFX1NWRyAmJiBwcm9wTmFtZSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZU5TKE5BTUVTUEFDRV9YTElOSywgcHJvcE5hbWUsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZShwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGVbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHVwZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZG9tTm9kZSwgcHJldmlvdXNQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydGllc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICAgICAgICB2YXIgcHJvcENvdW50ID0gcHJvcE5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcE5hbWVzW2ldO1xuICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBwcm9wZXJ0aWVzIHdpbGwgYmUgbnVsbGlmaWVkIGluc3RlYWQgb2YgbWlzc2luZyBpcyBieSBkZXNpZ25cbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJldmlvdXNQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSBwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNsYXNzXCIgcHJvcGVydHkgbWF5IG5vdCBiZSB1cGRhdGVkLiBVc2UgdGhlIFwiY2xhc3Nlc1wiIHByb3BlcnR5IGZvciBjb25kaXRpb25hbCBjc3MgY2xhc3Nlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnY2xhc3NlcycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZG9tTm9kZS5jbGFzc0xpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVDb3VudCA9IGNsYXNzTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3NOYW1lQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gISFwcm9wVmFsdWVbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzT24gPSAhIXByZXZpb3VzVmFsdWVbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uID09PSBwcmV2aW91c09uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlQ291bnQgPSBzdHlsZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0eWxlQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gc3R5bGVOYW1lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1N0eWxlVmFsdWUgPSBwcm9wVmFsdWVbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFN0eWxlVmFsdWUgPSBwcmV2aW91c1ZhbHVlW3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdHlsZVZhbHVlID09PSBvbGRTdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdTdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1N0eWxlVmFsdWUobmV3U3R5bGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucy5zdHlsZUFwcGx5ZXIoZG9tTm9kZSwgc3R5bGVOYW1lLCBuZXdTdHlsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zLnN0eWxlQXBwbHllcihkb21Ob2RlLCBzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wVmFsdWUgJiYgdHlwZW9mIHByZXZpb3VzVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbVZhbHVlID0gZG9tTm9kZVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21WYWx1ZSAhPT0gcHJvcFZhbHVlICAgIC8vIFRoZSAndmFsdWUnIGluIHRoZSBET00gdHJlZSAhPT0gbmV3VmFsdWVcbiYmIChkb21Ob2RlWydvbmlucHV0LXZhbHVlJ10gPyBkb21WYWx1ZSA9PT0gZG9tTm9kZVsnb25pbnB1dC12YWx1ZSddICAgIC8vIElmIHRoZSBsYXN0IHJlcG9ydGVkIHZhbHVlIHRvICdvbmlucHV0JyBkb2VzIG5vdCBtYXRjaCBkb21WYWx1ZSwgZG8gbm90aGluZyBhbmQgd2FpdCBmb3Igb25pbnB1dFxuIDogcHJvcFZhbHVlICE9PSBwcmV2aW91c1ZhbHVlICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZSBpZiB0aGUgdmRvbSBjaGFuZ2VkXG4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB2YWx1ZSwgZXZlbiBpZiB0aGUgdmlydHVhbCBET00gZGlkIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVbJ29uaW5wdXQtdmFsdWUnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGRvIG5vdCB1cGRhdGUgdGhlIGRvbU5vZGUsIG90aGVyd2lzZSB0aGUgY3Vyc29yIHBvc2l0aW9uIHdvdWxkIGJlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbnMgbWF5IG5vdCBiZSB1cGRhdGVkIG9uIHN1YnNlcXVlbnQgcmVuZGVycyAocHJvcGVydHk6ICcgKyBwcm9wTmFtZSArICcpLiBIaW50OiBkZWNsYXJlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zIG91dHNpZGUgdGhlIHJlbmRlcigpIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBwcm9wTmFtZSAhPT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uT3B0aW9ucy5uYW1lc3BhY2UgPT09IE5BTUVTUEFDRV9TVkcgJiYgcHJvcE5hbWUgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlTlMoTkFNRVNQQUNFX1hMSU5LLCBwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICdyb2xlJyAmJiBwcm9wVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZShwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlW3Byb3BOYW1lXSAhPT0gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcGVydGllc1VwZGF0ZWQ7XG4gICAgfTtcbiAgICB2YXIgZmluZEluZGV4T2ZDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgc2FtZUFzLCBzdGFydCkge1xuICAgICAgICBpZiAoc2FtZUFzLnZub2RlU2VsZWN0b3IgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBOZXZlciBzY2FuIGZvciB0ZXh0LW5vZGVzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzYW1lKGNoaWxkcmVuW2ldLCBzYW1lQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICB2YXIgbm9kZUFkZGVkID0gZnVuY3Rpb24gKHZOb2RlLCB0cmFuc2l0aW9ucykge1xuICAgICAgICBpZiAodk5vZGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIGVudGVyQW5pbWF0aW9uID0gdk5vZGUucHJvcGVydGllcy5lbnRlckFuaW1hdGlvbjtcbiAgICAgICAgICAgIGlmIChlbnRlckFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50ZXJBbmltYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXJBbmltYXRpb24odk5vZGUuZG9tTm9kZSwgdk5vZGUucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMuZW50ZXIodk5vZGUuZG9tTm9kZSwgdk5vZGUucHJvcGVydGllcywgZW50ZXJBbmltYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG5vZGVUb1JlbW92ZSA9IGZ1bmN0aW9uICh2Tm9kZSwgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSB2Tm9kZS5kb21Ob2RlO1xuICAgICAgICBpZiAodk5vZGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIGV4aXRBbmltYXRpb24gPSB2Tm9kZS5wcm9wZXJ0aWVzLmV4aXRBbmltYXRpb247XG4gICAgICAgICAgICBpZiAoZXhpdEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlRG9tTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4aXRBbmltYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdEFuaW1hdGlvbihkb21Ob2RlLCByZW1vdmVEb21Ob2RlLCB2Tm9kZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLmV4aXQodk5vZGUuZG9tTm9kZSwgdk5vZGUucHJvcGVydGllcywgZXhpdEFuaW1hdGlvbiwgcmVtb3ZlRG9tTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZG9tTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbU5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2hlY2tEaXN0aW5ndWlzaGFibGUgPSBmdW5jdGlvbiAoY2hpbGROb2RlcywgaW5kZXhUb0NoZWNrLCBwYXJlbnRWTm9kZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2luZGV4VG9DaGVja107XG4gICAgICAgIGlmIChjaGlsZE5vZGUudm5vZGVTZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjsgICAgLy8gVGV4dCBub2RlcyBuZWVkIG5vdCBiZSBkaXN0aW5ndWlzaGFibGVcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGNoaWxkTm9kZS5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIga2V5ID0gcHJvcGVydGllcyA/IHByb3BlcnRpZXMua2V5ID09PSB1bmRlZmluZWQgPyBwcm9wZXJ0aWVzLmJpbmQgOiBwcm9wZXJ0aWVzLmtleSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleFRvQ2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZShub2RlLCBjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnYWRkZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcmVudFZOb2RlLnZub2RlU2VsZWN0b3IgKyAnIGhhZCBhICcgKyBjaGlsZE5vZGUudm5vZGVTZWxlY3RvciArICcgY2hpbGQgJyArICdhZGRlZCwgYnV0IHRoZXJlIGlzIG5vdyBtb3JlIHRoYW4gb25lLiBZb3UgbXVzdCBhZGQgdW5pcXVlIGtleSBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhlbSBkaXN0aW5ndWlzaGFibGUuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJlbnRWTm9kZS52bm9kZVNlbGVjdG9yICsgJyBoYWQgYSAnICsgY2hpbGROb2RlLnZub2RlU2VsZWN0b3IgKyAnIGNoaWxkICcgKyAncmVtb3ZlZCwgYnV0IHRoZXJlIHdlcmUgbW9yZSB0aGFuIG9uZS4gWW91IG11c3QgYWRkIHVuaXF1ZSBrZXkgcHJvcGVydGllcyB0byBtYWtlIHRoZW0gZGlzdGluZ3Vpc2hhYmxlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRG9tO1xuICAgIHZhciB1cGRhdGVEb207XG4gICAgdmFyIHVwZGF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gKHZub2RlLCBkb21Ob2RlLCBvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChvbGRDaGlsZHJlbiA9PT0gbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvbGRDaGlsZHJlbiA9IG9sZENoaWxkcmVuIHx8IGVtcHR5QXJyYXk7XG4gICAgICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4gfHwgZW1wdHlBcnJheTtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB2YXIgbmV3Q2hpbGRyZW5MZW5ndGggPSBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IHByb2plY3Rpb25PcHRpb25zLnRyYW5zaXRpb25zO1xuICAgICAgICB2YXIgb2xkSW5kZXggPSAwO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSAwO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHRleHRVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChuZXdJbmRleCA8IG5ld0NoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb2xkQ2hpbGQgPSBvbGRJbmRleCA8IG9sZENoaWxkcmVuTGVuZ3RoID8gb2xkQ2hpbGRyZW5bb2xkSW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5bbmV3SW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZENoaWxkICE9PSB1bmRlZmluZWQgJiYgc2FtZShvbGRDaGlsZCwgbmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dFVwZGF0ZWQgPSB1cGRhdGVEb20ob2xkQ2hpbGQsIG5ld0NoaWxkLCBwcm9qZWN0aW9uT3B0aW9ucykgfHwgdGV4dFVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmRPbGRJbmRleCA9IGZpbmRJbmRleE9mQ2hpbGQob2xkQ2hpbGRyZW4sIG5ld0NoaWxkLCBvbGRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChmaW5kT2xkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJlY2VkaW5nIG1pc3NpbmcgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gb2xkSW5kZXg7IGkgPCBmaW5kT2xkSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVtb3ZlKG9sZENoaWxkcmVuW2ldLCB0cmFuc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Rpc3Rpbmd1aXNoYWJsZShvbGRDaGlsZHJlbiwgaSwgdm5vZGUsICdyZW1vdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGV4dFVwZGF0ZWQgPSB1cGRhdGVEb20ob2xkQ2hpbGRyZW5bZmluZE9sZEluZGV4XSwgbmV3Q2hpbGQsIHByb2plY3Rpb25PcHRpb25zKSB8fCB0ZXh0VXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXggPSBmaW5kT2xkSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEb20obmV3Q2hpbGQsIGRvbU5vZGUsIG9sZEluZGV4IDwgb2xkQ2hpbGRyZW5MZW5ndGggPyBvbGRDaGlsZHJlbltvbGRJbmRleF0uZG9tTm9kZSA6IHVuZGVmaW5lZCwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBub2RlQWRkZWQobmV3Q2hpbGQsIHRyYW5zaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEaXN0aW5ndWlzaGFibGUobmV3Q2hpbGRyZW4sIG5ld0luZGV4LCB2bm9kZSwgJ2FkZGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkQ2hpbGRyZW5MZW5ndGggPiBvbGRJbmRleCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyYWdtZW50c1xuICAgICAgICAgICAgZm9yIChpID0gb2xkSW5kZXg7IGkgPCBvbGRDaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVtb3ZlKG9sZENoaWxkcmVuW2ldLCB0cmFuc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgY2hlY2tEaXN0aW5ndWlzaGFibGUob2xkQ2hpbGRyZW4sIGksIHZub2RlLCAncmVtb3ZlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0VXBkYXRlZDtcbiAgICB9O1xuICAgIHZhciBhZGRDaGlsZHJlbiA9IGZ1bmN0aW9uIChkb21Ob2RlLCBjaGlsZHJlbiwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNyZWF0ZURvbShjaGlsZHJlbltpXSwgZG9tTm9kZSwgdW5kZWZpbmVkLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbml0UHJvcGVydGllc0FuZENoaWxkcmVuID0gZnVuY3Rpb24gKGRvbU5vZGUsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICBhZGRDaGlsZHJlbihkb21Ob2RlLCB2bm9kZS5jaGlsZHJlbiwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAvLyBjaGlsZHJlbiBiZWZvcmUgcHJvcGVydGllcywgbmVlZGVkIGZvciB2YWx1ZSBwcm9wZXJ0eSBvZiA8c2VsZWN0Pi5cbiAgICAgICAgaWYgKHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIGRvbU5vZGUudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHNldFByb3BlcnRpZXMoZG9tTm9kZSwgdm5vZGUucHJvcGVydGllcywgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAodm5vZGUucHJvcGVydGllcyAmJiB2bm9kZS5wcm9wZXJ0aWVzLmFmdGVyQ3JlYXRlKSB7XG4gICAgICAgICAgICB2bm9kZS5wcm9wZXJ0aWVzLmFmdGVyQ3JlYXRlLmFwcGx5KHZub2RlLnByb3BlcnRpZXMuYmluZCB8fCB2bm9kZS5wcm9wZXJ0aWVzLCBbXG4gICAgICAgICAgICAgICAgZG9tTm9kZSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB2bm9kZS52bm9kZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHZub2RlLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjcmVhdGVEb20gPSBmdW5jdGlvbiAodm5vZGUsIHBhcmVudE5vZGUsIGluc2VydEJlZm9yZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUsIGksIGMsIHN0YXJ0ID0gMCwgdHlwZSwgZm91bmQ7XG4gICAgICAgIHZhciB2bm9kZVNlbGVjdG9yID0gdm5vZGUudm5vZGVTZWxlY3RvcjtcbiAgICAgICAgdmFyIGRvYyA9IHBhcmVudE5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKHZub2RlU2VsZWN0b3IgPT09ICcnKSB7XG4gICAgICAgICAgICBkb21Ob2RlID0gdm5vZGUuZG9tTm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvbU5vZGUsIGluc2VydEJlZm9yZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9tTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IHZub2RlU2VsZWN0b3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjID0gdm5vZGVTZWxlY3Rvci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlU2VsZWN0b3IubGVuZ3RoIHx8IGMgPT09ICcuJyB8fCBjID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZub2RlU2VsZWN0b3IuY2hhckF0KHN0YXJ0IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdm5vZGVTZWxlY3Rvci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuY2xhc3NMaXN0LmFkZChmb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLmlkID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBleHRlbmQocHJvamVjdGlvbk9wdGlvbnMsIHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0VfU1ZHIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb25PcHRpb25zLm5hbWVzcGFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IHZub2RlLmRvbU5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudE5TKHByb2plY3Rpb25PcHRpb25zLm5hbWVzcGFjZSwgZm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gdm5vZGUuZG9tTm9kZSA9IHZub2RlLmRvbU5vZGUgfHwgZG9jLmNyZWF0ZUVsZW1lbnQoZm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gJ2lucHV0JyAmJiB2bm9kZS5wcm9wZXJ0aWVzICYmIHZub2RlLnByb3BlcnRpZXMudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOCBhbmQgb2xkZXIgZG9uJ3Qgc3VwcG9ydCBzZXR0aW5nIGlucHV0IHR5cGUgYWZ0ZXIgdGhlIERPTSBOb2RlIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZSgndHlwZScsIHZub2RlLnByb3BlcnRpZXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydEJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9tTm9kZSwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tTm9kZS5wYXJlbnROb2RlICE9PSBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRQcm9wZXJ0aWVzQW5kQ2hpbGRyZW4oZG9tTm9kZSwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlRG9tID0gZnVuY3Rpb24gKHByZXZpb3VzLCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSBwcmV2aW91cy5kb21Ob2RlO1xuICAgICAgICB2YXIgdGV4dFVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByZXZpb3VzID09PSB2bm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAvLyBCeSBjb250cmFjdCwgVk5vZGUgb2JqZWN0cyBtYXkgbm90IGJlIG1vZGlmaWVkIGFueW1vcmUgYWZ0ZXIgcGFzc2luZyB0aGVtIHRvIG1hcXVldHRlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZub2RlLnZub2RlU2VsZWN0b3IgPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodm5vZGUudGV4dCAhPT0gcHJldmlvdXMudGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWTm9kZSA9IGRvbU5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgICAgICAgICBkb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1ZOb2RlLCBkb21Ob2RlKTtcbiAgICAgICAgICAgICAgICB2bm9kZS5kb21Ob2RlID0gbmV3Vk5vZGU7XG4gICAgICAgICAgICAgICAgdGV4dFVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0VXBkYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS52bm9kZVNlbGVjdG9yLmxhc3RJbmRleE9mKCdzdmcnLCAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gZXh0ZW5kKHByb2plY3Rpb25PcHRpb25zLCB7IG5hbWVzcGFjZTogTkFNRVNQQUNFX1NWRyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cy50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnJlbW92ZUNoaWxkKGRvbU5vZGUuZmlyc3RDaGlsZCk7ICAgIC8vIHRoZSBvbmx5IHRleHRub2RlIHByZXN1bWFibHlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnRleHRDb250ZW50ID0gdm5vZGUudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlQ2hpbGRyZW4odm5vZGUsIGRvbU5vZGUsIHByZXZpb3VzLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcHJvamVjdGlvbk9wdGlvbnMpIHx8IHVwZGF0ZWQ7XG4gICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlUHJvcGVydGllcyhkb21Ob2RlLCBwcmV2aW91cy5wcm9wZXJ0aWVzLCB2bm9kZS5wcm9wZXJ0aWVzLCBwcm9qZWN0aW9uT3B0aW9ucykgfHwgdXBkYXRlZDtcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wZXJ0aWVzICYmIHZub2RlLnByb3BlcnRpZXMuYWZ0ZXJVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5wcm9wZXJ0aWVzLmFmdGVyVXBkYXRlLmFwcGx5KHZub2RlLnByb3BlcnRpZXMuYmluZCB8fCB2bm9kZS5wcm9wZXJ0aWVzLCBbXG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZS52bm9kZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkICYmIHZub2RlLnByb3BlcnRpZXMgJiYgdm5vZGUucHJvcGVydGllcy51cGRhdGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZub2RlLnByb3BlcnRpZXMudXBkYXRlQW5pbWF0aW9uKGRvbU5vZGUsIHZub2RlLnByb3BlcnRpZXMsIHByZXZpb3VzLnByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLmRvbU5vZGUgPSBwcmV2aW91cy5kb21Ob2RlO1xuICAgICAgICByZXR1cm4gdGV4dFVwZGF0ZWQ7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlUHJvamVjdGlvbiA9IGZ1bmN0aW9uICh2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRWbm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZS52bm9kZVNlbGVjdG9yICE9PSB1cGRhdGVkVm5vZGUudm5vZGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWxlY3RvciBmb3IgdGhlIHJvb3QgVk5vZGUgbWF5IG5vdCBiZSBjaGFuZ2VkLiAoY29uc2lkZXIgdXNpbmcgZG9tLm1lcmdlIGFuZCBhZGQgb25lIGV4dHJhIGxldmVsIHRvIHRoZSB2aXJ0dWFsIERPTSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlRG9tKHZub2RlLCB1cGRhdGVkVm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2bm9kZSA9IHVwZGF0ZWRWbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21Ob2RlOiB2bm9kZS5kb21Ob2RlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBUaGUgb3RoZXIgdHdvIHBhcmFtZXRlcnMgYXJlIG5vdCBhZGRlZCBoZXJlLCBiZWNhdXNlIHRoZSBUeXBlc2NyaXB0IGNvbXBpbGVyIGNyZWF0ZXMgc3Vycm9nYXRlIGNvZGUgZm9yIGRlc3RydWN0dXJpbmcgJ2NoaWxkcmVuJy5cbiAgICBleHBvcnRzLmggPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRJbmRleCA9IDE7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzICYmICFwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd2bm9kZVNlbGVjdG9yJykgJiYgIUFycmF5LmlzQXJyYXkocHJvcGVydGllcykgJiYgdHlwZW9mIHByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjaGlsZEluZGV4ID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsIHByb3BlcnRpZXMgYXJndW1lbnQgd2FzIG9taXR0ZWRcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQ7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAvLyBSZWNvZ25pemUgYSBjb21tb24gc3BlY2lhbCBjYXNlIHdoZXJlIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgdGV4dCBub2RlXG4gICAgICAgIGlmIChhcmdzTGVuZ3RoID09PSBjaGlsZEluZGV4ICsgMSkge1xuICAgICAgICAgICAgdmFyIG9ubHlDaGlsZCA9IGFyZ3VtZW50c1tjaGlsZEluZGV4XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25seUNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBvbmx5Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9ubHlDaGlsZCAhPT0gdW5kZWZpbmVkICYmIG9ubHlDaGlsZCAhPT0gbnVsbCAmJiBvbmx5Q2hpbGQubGVuZ3RoID09PSAxICYmIHR5cGVvZiBvbmx5Q2hpbGRbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG9ubHlDaGlsZFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yICg7IGNoaWxkSW5kZXggPCBhcmdzTGVuZ3RoOyBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBhcmd1bWVudHNbY2hpbGRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKHNlbGVjdG9yLCBjaGlsZCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoJ3Zub2RlU2VsZWN0b3InKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRvVGV4dFZOb2RlKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2bm9kZVNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0ID09PSAnJyA/IHVuZGVmaW5lZCA6IHRleHQsXG4gICAgICAgICAgICBkb21Ob2RlOiBudWxsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAqIENvbnRhaW5zIHNpbXBsZSBsb3ctbGV2ZWwgdXRpbGl0eSBmdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSB0aGUgcmVhbCBET00uXG4gKi9cbiAgICBleHBvcnRzLmRvbSA9IHtcbiAgICAgICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWwgRE9NIHRyZWUgZnJvbSBgdm5vZGVgLiBUaGUgW1tQcm9qZWN0aW9uXV0gb2JqZWN0IHJldHVybmVkIHdpbGwgY29udGFpbiB0aGUgcmVzdWx0aW5nIERPTSBOb2RlIGluXG4gICAgICogaXRzIFtbUHJvamVjdGlvbi5kb21Ob2RlfGRvbU5vZGVdXSBwcm9wZXJ0eS5cbiAgICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIG1ldGhvZC4gVXNlcnMgd2lsbCB0eXBpY2FsbHkgdXNlIGEgW1tQcm9qZWN0b3JdXSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB2bm9kZSAtIFRoZSByb290IG9mIHRoZSB2aXJ0dWFsIERPTSB0cmVlIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIFtbaF1dIGZ1bmN0aW9uLiBOT1RFOiBbW1ZOb2RlXV1cbiAgICAgKiBvYmplY3RzIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25PcHRpb25zIC0gT3B0aW9ucyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgdXBkYXRlIHRoZSBwcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1Byb2plY3Rpb25dXSB3aGljaCBhbHNvIGNvbnRhaW5zIHRoZSBET00gTm9kZSB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICh2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMocHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgY3JlYXRlRG9tKHZub2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgdW5kZWZpbmVkLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvamVjdGlvbih2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgbmV3IGNoaWxkIG5vZGUgdG8gdGhlIERPTSB3aGljaCBpcyBnZW5lcmF0ZWQgZnJvbSBhIFtbVk5vZGVdXS5cbiAgICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIG1ldGhvZC4gVXNlcnMgd2lsbCB0eXBpY2FsbHkgdXNlIGEgW1tQcm9qZWN0b3JdXSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBwYXJlbnROb2RlIC0gVGhlIHBhcmVudCBub2RlIGZvciB0aGUgbmV3IGNoaWxkIG5vZGUuXG4gICAgICogQHBhcmFtIHZub2RlIC0gVGhlIHJvb3Qgb2YgdGhlIHZpcnR1YWwgRE9NIHRyZWUgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgW1toXV0gZnVuY3Rpb24uIE5PVEU6IFtbVk5vZGVdXVxuICAgICAqIG9iamVjdHMgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdGlvbk9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCB1cGRhdGUgdGhlIFtbUHJvamVjdGlvbl1dLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1Byb2plY3Rpb25dXSB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMocHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgY3JlYXRlRG9tKHZub2RlLCBwYXJlbnROb2RlLCB1bmRlZmluZWQsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm9qZWN0aW9uKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBuZXcgRE9NIG5vZGUgd2hpY2ggaXMgZ2VuZXJhdGVkIGZyb20gYSBbW1ZOb2RlXV0uXG4gICAgICogVGhpcyBpcyBhIGxvdy1sZXZlbCBtZXRob2QuIFVzZXJzIHdpbCB0eXBpY2FsbHkgdXNlIGEgW1tQcm9qZWN0b3JdXSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBiZWZvcmVOb2RlIC0gVGhlIG5vZGUgdGhhdCB0aGUgRE9NIE5vZGUgaXMgaW5zZXJ0ZWQgYmVmb3JlLlxuICAgICAqIEBwYXJhbSB2bm9kZSAtIFRoZSByb290IG9mIHRoZSB2aXJ0dWFsIERPTSB0cmVlIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIFtbaF1dIGZ1bmN0aW9uLlxuICAgICAqIE5PVEU6IFtbVk5vZGVdXSBvYmplY3RzIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25PcHRpb25zIC0gT3B0aW9ucyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgdXBkYXRlIHRoZSBwcm9qZWN0aW9uLCBzZWUgW1tjcmVhdGVQcm9qZWN0b3JdXS5cbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQcm9qZWN0aW9uXV0gdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoYmVmb3JlTm9kZSwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zKHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIGNyZWF0ZURvbSh2bm9kZSwgYmVmb3JlTm9kZS5wYXJlbnROb2RlLCBiZWZvcmVOb2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvamVjdGlvbih2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBuZXcgRE9NIG5vZGUgd2hpY2ggaXMgZ2VuZXJhdGVkIGZyb20gYSBbW1ZOb2RlXV0gd2l0aCBhbiBleGlzdGluZyBET00gTm9kZS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIHZpcnR1YWwgRE9NIGFuZCB0aGUgcmVhbCBET00gd2lsbCBoYXZlIG9uZSBvdmVybGFwcGluZyBlbGVtZW50LlxuICAgICAqIFRoZXJlZm9yZSB0aGUgc2VsZWN0b3IgZm9yIHRoZSByb290IFtbVk5vZGVdXSB3aWxsIGJlIGlnbm9yZWQsIGJ1dCBpdHMgcHJvcGVydGllcyBhbmQgY2hpbGRyZW4gd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBFbGVtZW50IHByb3ZpZGVkLlxuICAgICAqIFRoaXMgaXMgYSBsb3ctbGV2ZWwgbWV0aG9kLiBVc2VycyB3aWwgdHlwaWNhbGx5IHVzZSBhIFtbUHJvamVjdG9yXV0gaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBleGlzdGluZyBlbGVtZW50IHRvIGFkb3B0IGFzIHRoZSByb290IG9mIHRoZSBuZXcgdmlydHVhbCBET00uIEV4aXN0aW5nIGF0dHJpYnV0ZXMgYW5kIGNoaWxkIG5vZGVzIGFyZSBwcmVzZXJ2ZWQuXG4gICAgICogQHBhcmFtIHZub2RlIC0gVGhlIHJvb3Qgb2YgdGhlIHZpcnR1YWwgRE9NIHRyZWUgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgW1toXV0gZnVuY3Rpb24uIE5PVEU6IFtbVk5vZGVdXSBvYmplY3RzXG4gICAgICogbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdGlvbk9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCB1cGRhdGUgdGhlIHByb2plY3Rpb24sIHNlZSBbW2NyZWF0ZVByb2plY3Rvcl1dLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1Byb2plY3Rpb25dXSB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgICAgICBtZXJnZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyhwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICB2bm9kZS5kb21Ob2RlID0gZWxlbWVudDtcbiAgICAgICAgICAgIGluaXRQcm9wZXJ0aWVzQW5kQ2hpbGRyZW4oZWxlbWVudCwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm9qZWN0aW9uKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIERPTSBub2RlIHdpdGggYSBub2RlIGdlbmVyYXRlZCBmcm9tIGEgW1tWTm9kZV1dLlxuICAgICAqIFRoaXMgaXMgYSBsb3ctbGV2ZWwgbWV0aG9kLiBVc2VycyB3aWxsIHR5cGljYWxseSB1c2UgYSBbW1Byb2plY3Rvcl1dIGluc3RlYWQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgbm9kZSBmb3IgdGhlIFtbVk5vZGVdXSB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB2bm9kZSAtIFRoZSByb290IG9mIHRoZSB2aXJ0dWFsIERPTSB0cmVlIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIFtbaF1dIGZ1bmN0aW9uLiBOT1RFOiBbW1ZOb2RlXV1cbiAgICAgKiBvYmplY3RzIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25PcHRpb25zIC0gT3B0aW9ucyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgdXBkYXRlIHRoZSBbW1Byb2plY3Rpb25dXS5cbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQcm9qZWN0aW9uXV0gdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyhwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICBjcmVhdGVEb20odm5vZGUsIGVsZW1lbnQucGFyZW50Tm9kZSwgZWxlbWVudCwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb2plY3Rpb24odm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gKiBDcmVhdGVzIGEgW1tDYWxjdWxhdGlvbkNhY2hlXV0gb2JqZWN0LCB1c2VmdWwgZm9yIGNhY2hpbmcgW1tWTm9kZV1dIHRyZWVzLlxuICogSW4gcHJhY3RpY2UsIGNhY2hpbmcgb2YgW1tWTm9kZV1dIHRyZWVzIGlzIG5vdCBuZWVkZWQsIGJlY2F1c2UgYWNoaWV2aW5nIDYwIGZyYW1lcyBwZXIgc2Vjb25kIGlzIGFsbW9zdCBuZXZlciBhIHByb2JsZW0uXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIFtbQ2FsY3VsYXRpb25DYWNoZV1dLlxuICpcbiAqIEBwYXJhbSA8UmVzdWx0PiBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdGhhdCBpcyBjYWNoZWQuXG4gKi9cbiAgICBleHBvcnRzLmNyZWF0ZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FjaGVkSW5wdXRzO1xuICAgICAgICB2YXIgY2FjaGVkT3V0Y29tZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRPdXRjb21lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNhY2hlZElucHV0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uIChpbnB1dHMsIGNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZElucHV0cykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZElucHV0c1tpXSAhPT0gaW5wdXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkT3V0Y29tZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZE91dGNvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkT3V0Y29tZSA9IGNhbGN1bGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZElucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE91dGNvbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTWFwcGluZ30gaW5zdGFuY2UgdGhhdCBrZWVwcyBhbiBhcnJheSBvZiByZXN1bHQgb2JqZWN0cyBzeW5jaHJvbml6ZWQgd2l0aCBhbiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0cy5cbiAqIFNlZSB7QGxpbmsgaHR0cDovL21hcXVldHRlanMub3JnL2RvY3MvYXJyYXlzLmh0bWx8V29ya2luZyB3aXRoIGFycmF5c30uXG4gKlxuICogQHBhcmFtIDxTb3VyY2U+ICAgICAgIFRoZSB0eXBlIG9mIHNvdXJjZSBpdGVtcy4gQSBkYXRhYmFzZS1yZWNvcmQgZm9yIGluc3RhbmNlLlxuICogQHBhcmFtIDxUYXJnZXQ+ICAgICAgIFRoZSB0eXBlIG9mIHRhcmdldCBpdGVtcy4gQSBbW0NvbXBvbmVudF1dIGZvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBnZXRTb3VyY2VLZXkgICBgZnVuY3Rpb24oc291cmNlKWAgdGhhdCBtdXN0IHJldHVybiBhIGtleSB0byBpZGVudGlmeSBlYWNoIHNvdXJjZSBvYmplY3QuIFRoZSByZXN1bHQgbXVzdCBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gKiBAcGFyYW0gY3JlYXRlUmVzdWx0ICAgYGZ1bmN0aW9uKHNvdXJjZSwgaW5kZXgpYCB0aGF0IG11c3QgY3JlYXRlIGEgbmV3IHJlc3VsdCBvYmplY3QgZnJvbSBhIGdpdmVuIHNvdXJjZS4gVGhpcyBmdW5jdGlvbiBpcyBpZGVudGljYWxcbiAqICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgYGNhbGxiYWNrYCBhcmd1bWVudCBpbiBgQXJyYXkubWFwKGNhbGxiYWNrKWAuXG4gKiBAcGFyYW0gdXBkYXRlUmVzdWx0ICAgYGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0LCBpbmRleClgIHRoYXQgdXBkYXRlcyBhIHJlc3VsdCB0byBhbiB1cGRhdGVkIHNvdXJjZS5cbiAqL1xuICAgIGV4cG9ydHMuY3JlYXRlTWFwcGluZyA9IGZ1bmN0aW9uIChnZXRTb3VyY2VLZXksIGNyZWF0ZVJlc3VsdCwgdXBkYXRlUmVzdWx0KSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHRzOiByZXN1bHRzLFxuICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiAobmV3U291cmNlcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdLZXlzID0gbmV3U291cmNlcy5tYXAoZ2V0U291cmNlS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVGFyZ2V0cyA9IHJlc3VsdHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gbmV3U291cmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUtleSA9IG5ld0tleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VLZXkgPT09IGtleXNbb2xkSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gb2xkVGFyZ2V0c1tvbGRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoc291cmNlLCBvbGRUYXJnZXRzW29sZEluZGV4XSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGtleXMubGVuZ3RoICsgMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaEluZGV4ID0gKG9sZEluZGV4ICsgaikgJSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tzZWFyY2hJbmRleF0gPT09IHNvdXJjZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gb2xkVGFyZ2V0c1tzZWFyY2hJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChuZXdTb3VyY2VzW2ldLCBvbGRUYXJnZXRzW3NlYXJjaEluZGV4XSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEluZGV4ID0gc2VhcmNoSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gY3JlYXRlUmVzdWx0KHNvdXJjZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5sZW5ndGggPSBuZXdTb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBrZXlzID0gbmV3S2V5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICogQ3JlYXRlcyBhIFtbUHJvamVjdG9yXV0gaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIHByb2plY3Rpb25PcHRpb25zLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgW1tQcm9qZWN0b3JdXS5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdG9yT3B0aW9ucyAgIE9wdGlvbnMgdGhhdCBpbmZsdWVuY2UgaG93IHRoZSBET00gaXMgcmVuZGVyZWQgYW5kIHVwZGF0ZWQuXG4gKi9cbiAgICBleHBvcnRzLmNyZWF0ZVByb2plY3RvciA9IGZ1bmN0aW9uIChwcm9qZWN0b3JPcHRpb25zKSB7XG4gICAgICAgIHZhciBwcm9qZWN0b3I7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uT3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zKHByb2plY3Rvck9wdGlvbnMpO1xuICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucy5ldmVudEhhbmRsZXJJbnRlcmNlcHRvciA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGV2ZW50SGFuZGxlciwgZG9tTm9kZSwgcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmNlcHQgZnVuY3Rpb24gY2FsbHMgKGV2ZW50IGhhbmRsZXJzKSB0byBkbyBhIHJlbmRlciBhZnRlcndhcmRzLlxuICAgICAgICAgICAgICAgIHByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudEhhbmRsZXIuYXBwbHkocHJvcGVydGllcy5iaW5kIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVuZGVyQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlZDtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHByb2plY3Rpb25zID0gW107XG4gICAgICAgIHZhciByZW5kZXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcHJvamVjdGlvbnMgYXJyYXlcbiAgICAgICAgdmFyIGRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAgIC8vIFRoZSBsYXN0IHJlbmRlciB0aHJldyBhbiBlcnJvciwgaXQgc2hvdWxkIGJlIGxvZ2dlZCBpbiB0aGUgYnJvd3NlciBjb25zb2xlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2plY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRWbm9kZSA9IHJlbmRlckZ1bmN0aW9uc1tpXSgpO1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25zW2ldLnVwZGF0ZSh1cGRhdGVkVm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdG9yID0ge1xuICAgICAgICAgICAgcmVuZGVyTm93OiBkb1JlbmRlcixcbiAgICAgICAgICAgIHNjaGVkdWxlUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY2hlZHVsZWQgJiYgIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvUmVuZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc2NoZWR1bGVkKTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVuZGVyQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0b3Iuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbnMucHVzaChleHBvcnRzLmRvbS5hcHBlbmQocGFyZW50Tm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbigpLCBwcm9qZWN0aW9uT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJlbmRlckZ1bmN0aW9ucy5wdXNoKHJlbmRlck1hcXVldHRlRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGJlZm9yZU5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9ucy5wdXNoKGV4cG9ydHMuZG9tLmluc2VydEJlZm9yZShiZWZvcmVOb2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKCksIHByb2plY3Rpb25PcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRnVuY3Rpb25zLnB1c2gocmVuZGVyTWFxdWV0dGVGdW5jdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChkb21Ob2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbnMucHVzaChleHBvcnRzLmRvbS5tZXJnZShkb21Ob2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKCksIHByb2plY3Rpb25PcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRnVuY3Rpb25zLnB1c2gocmVuZGVyTWFxdWV0dGVGdW5jdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKGRvbU5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9ucy5wdXNoKGV4cG9ydHMuZG9tLnJlcGxhY2UoZG9tTm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbigpLCBwcm9qZWN0aW9uT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJlbmRlckZ1bmN0aW9ucy5wdXNoKHJlbmRlck1hcXVldHRlRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRldGFjaDogZnVuY3Rpb24gKHJlbmRlck1hcXVldHRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRlckZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyRnVuY3Rpb25zW2ldID09PSByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJGdW5jdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb25zLnNwbGljZShpLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlck1hcXVldHRlRnVuY3Rpb24gd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdG9yO1xuICAgIH07XG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXF1ZXR0ZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21hcXVldHRlL2Rpc3QvbWFxdWV0dGUuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVk5vZGVBcHAgfSBmcm9tICcuL2ZhY2FkZS9WTm9kZUFwcCc7XG5cbig8YW55PndpbmRvdykubHVjY2EgPSBuZXcgVk5vZGVBcHAoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXgudHMiLCJpbXBvcnQgeyBNb2RlbCB9IGZyb20gJy4uL2NvcmUvTW9kZWwuaW50ZXJmYWNlJztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi9jb3JlL1ZpZXcuaW50ZXJmYWNlJztcbmltcG9ydCB7IFJlY2VpdmVyIH0gZnJvbSAnLi4vY29yZS9SZWNlaXZlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25Db250ZXh0IH0gZnJvbSAnLi4vY29yZS9BcHBsaWNhdGlvbkNvbnRleHQuaW50ZXJmYWNlJztcbmltcG9ydCB7IEJhc2VNb2RlbCB9IGZyb20gJy4uL21vZGVsL0Jhc2VNb2RlbCc7XG5pbXBvcnQgeyBWTm9kZVZpZXcgfSBmcm9tICcuLi92aWV3L1ZOb2RlVmlldyc7XG5pbXBvcnQgeyBCYXNlUmVjZWl2ZXIgfSBmcm9tICcuLi9hY3Rpb24vQmFzZVJlY2VpdmVyJztcbmltcG9ydCB7IEFjdGlvbkRpc3BhdGNoZXIgfSBmcm9tICcuLi9hY3Rpb24vQWN0aW9uRGlzcGF0Y2hlcidcbmltcG9ydCB7IEFjdGlvblF1ZXVlIH0gZnJvbSAnLi4vYWN0aW9uL0FjdGlvblF1ZXVlJztcbmltcG9ydCB7IFZOb2RlUmVuZGVyZXIgYXMgUmVuZGVyZXIgfSBmcm9tICcuLi9yZW5kZXIvVk5vZGVSZW5kZXJlcic7XG5pbXBvcnQgeyBWTm9kZVByb3ZpZGVyIH0gZnJvbSAnLi4vcmVuZGVyL1ZOb2RlUHJvdmlkZXInO1xuaW1wb3J0IHsgRGlzcGxheVByb3ZpZGVyTm9kZSwgRGlzcGxheU5vZGUgfSBmcm9tICcuLi9jb3JlL2NvcmUudHlwZSdcblxuZXhwb3J0IGNsYXNzIFZOb2RlQXBwIGltcGxlbWVudHMgQXBwbGljYXRpb25Db250ZXh0PERpc3BsYXlQcm92aWRlck5vZGUsIERpc3BsYXlOb2RlPiB7XG4gICAgcHJpdmF0ZSBtb2RlbHM6TWFwPHN0cmluZywgTW9kZWw+O1xuICAgIHByaXZhdGUgdmlld3M6TWFwPHN0cmluZywgVk5vZGVWaWV3PjtcbiAgICBwcml2YXRlIHJlY3Y6TWFwPHN0cmluZywgUmVjZWl2ZXI+O1xuICAgIHByaXZhdGUgaHRtbFByb3ZpZGVyOlZOb2RlUHJvdmlkZXI7XG4gICAgcHJpdmF0ZSB2aWV3SW5qZWN0b3I6RnVuY3Rpb247XG4gICAgcHJpdmF0ZSBhY3Rpb25EaXNwYXRjaGVyOkFjdGlvbkRpc3BhdGNoZXI7XG4gICAgcHJpdmF0ZSBhY3Rpb25RdWV1ZTpBY3Rpb25RdWV1ZTtcbiAgICBwcml2YXRlIHJlbmRlcmVyOlJlbmRlcmVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1hcDxzdHJpbmcsIE1vZGVsPigpO1xuICAgICAgICB0aGlzLnZpZXdzID0gbmV3IE1hcDxzdHJpbmcsIFZOb2RlVmlldz4oKTtcbiAgICAgICAgdGhpcy5yZWN2ID0gbmV3IE1hcDxzdHJpbmcsIFJlY2VpdmVyPigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uUXVldWUoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25EaXNwYXRjaGVyID0gbmV3IEFjdGlvbkRpc3BhdGNoZXIodGhpcy5hY3Rpb25RdWV1ZS5xdWV1ZS5iaW5kKHRoaXMuYWN0aW9uUXVldWUpKVxuICAgICAgICB0aGlzLmh0bWxQcm92aWRlciA9IHRoaXMucmVuZGVyZXIuZ2V0Vmlld2FibGVQcm92aWRlcigpO1xuICAgICAgICB0aGlzLnZpZXdJbmplY3RvciA9IHRoaXMucmVuZGVyZXIuZ2V0Vmlld0luamVjdG9yKHRoaXMudmlld3MpO1xuICAgIH1cblxuICAgIHB1YmxpYyBtb2RlbChuYW1lOnN0cmluZyk6TW9kZWwge1xuICAgICAgICBsZXQgbTpNb2RlbCA9IG5ldyBCYXNlTW9kZWwobmFtZSk7XG4gICAgICAgIHRoaXMubW9kZWxzLnNldChuYW1lLCBtKVxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdmlldyhuYW1lOnN0cmluZyk6VmlldzxEaXNwbGF5UHJvdmlkZXJOb2RlPiB7XG4gICAgICAgIGxldCB2ID0gbmV3IFZOb2RlVmlldyhuYW1lLFxuICAgICAgICAgICAgdGhpcy5odG1sUHJvdmlkZXIsXG4gICAgICAgICAgICB0aGlzLnZpZXdJbmplY3RvcixcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uRGlzcGF0Y2hlcik7XG4gICAgICAgIHRoaXMudmlld3Muc2V0KG5hbWUsIHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm0obmFtZTpzdHJpbmcpOlJlY2VpdmVyIHtcbiAgICAgICAgbGV0IHIgPSBuZXcgQmFzZVJlY2VpdmVyKG5hbWUpO1xuICAgICAgICB0aGlzLnJlY3Yuc2V0KG5hbWUsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdGljaygpOnZvaWQge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCB0aGlzLnRpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYWN0aW9uVGljaygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KGRvbU5vZGU6RGlzcGxheU5vZGUpOnZvaWQge1xuICAgICAgICB0aGlzLnJlY3YuZm9yRWFjaCgocjpSZWNlaXZlcikgPT4geyByLmluaXQodGhpcy5tb2RlbHMsIHRoaXMudmlld3MpIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm1vdW50KGRvbU5vZGUsIHRoaXMuZ2V0QXBwUmVuZGVyVHJlZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGlvblRpY2soKSB7XG4gICAgICAgIGxldCBuZXh0QWN0aW9uID0gdGhpcy5hY3Rpb25RdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmIChuZXh0QWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlY3YuZm9yRWFjaCgocjpSZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHIudHJpZ2dlclN0YXRlQ2hhbmdlKG5leHRBY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEFwcFJlbmRlclRyZWUoKSB7XG4gICAgICAgIGxldCByZWNlaXZlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVjdi52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnN0aXRjaCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXJzLm1hcCgocjpSZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByLmdldFJlbmRlclRyZWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZmFjYWRlL1ZOb2RlQXBwLnRzIiwiaW1wb3J0IHsgTW9kZWwgfSBmcm9tICcuLi9jb3JlL01vZGVsLmludGVyZmFjZSc7XG5pbXBvcnQgeyBIYW5kbGVyIH0gZnJvbSAnLi4vY29yZS9IYW5kbGVyVC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSHR0cFNlcnZpY2UgfSBmcm9tICcuLi9uZXQvSHR0cFNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgQmFzZU1vZGVsIGltcGxlbWVudHMgTW9kZWwge1xuICAgIHByaXZhdGUgbmFtZTpzdHJpbmc7XG4gICAgcHJpdmF0ZSBkYXRhOmFueTtcbiAgICBwcml2YXRlIGhhbmRsZXJzOk1hcDxzdHJpbmcsIEhhbmRsZXI8dm9pZD4+O1xuICAgIHByaXZhdGUgaHR0cDpIdHRwU2VydmljZTtcbiAgICBwcml2YXRlIGlzTG9hZGluZzpib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IobmFtZTpzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwPHN0cmluZywgSGFuZGxlcjx2b2lkPj4oKTtcbiAgICAgICAgdGhpcy5odHRwID0gbmV3IEh0dHBTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGRlZmluZShkYXRhOmFueSk6TW9kZWwge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0KHVybDpzdHJpbmcpOk1vZGVsIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmh0dHAuZ2V0KHVybCwgKHJlczphbnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHJlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RGF0YSgpOmFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZShzdGF0ZU5hbWU6c3RyaW5nLCBoYW5kbGVyOkhhbmRsZXI8dm9pZD4pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5zZXQoc3RhdGVOYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIHNhdmUoKTooKT0+IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKCgpID0+IGZhbHNlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVmcmVzaCgpOnZvaWQge31cblxuICAgIHB1YmxpYyBoYW5kbGVTdGF0ZUNoYW5nZShzdGF0ZU5hbWU6c3RyaW5nLCBldnQ/OkV2ZW50KTp2b2lkIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLmdldChzdGF0ZU5hbWUpO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBbdGhpcy5kYXRhLCBldnRdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGBzdGF0ZSAke3N0YXRlTmFtZX0gbm90IGhhbmRsZWRgKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL0Jhc2VNb2RlbC50cyIsImV4cG9ydCBjbGFzcyBIdHRwU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgICBwdWJsaWMgZ2V0KHVybDpzdHJpbmcsIGNhbGxiYWNrOkZ1bmN0aW9uKTphbnkge1xuICAgICAgICBsZXQgeGhyOlhNTEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImpzb25cIjtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcG9zdCgpOmFueSB7XG5cbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL25ldC9IdHRwU2VydmljZS50cyIsImltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi9jb3JlL1ZpZXcuaW50ZXJmYWNlJztcbmltcG9ydCB7IE1vZGVsIH0gZnJvbSAnLi4vY29yZS9Nb2RlbC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGlzcGxheVByb3ZpZGVyTm9kZSB9IGZyb20gJy4uL2NvcmUvY29yZS50eXBlJ1xuaW1wb3J0IHsgSGFuZGxlciB9IGZyb20gJy4uL2NvcmUvSGFuZGxlclQuaW50ZXJmYWNlJztcbmltcG9ydCB7IEluamVjdG9yIH0gZnJvbSAnLi4vY29yZS9JbmplY3Rvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVmlld0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vY29yZS9jb3JlLnR5cGUnO1xuaW1wb3J0IHsgVmFsdWVJbmplY3RvciB9IGZyb20gJy4uL21vZGVsL1ZhbHVlSW5qZWN0b3InO1xuaW1wb3J0IHsgQWN0aW9uRGlzcGF0Y2hlciB9IGZyb20gJy4uL2FjdGlvbi9BY3Rpb25EaXNwYXRjaGVyJ1xuaW1wb3J0IHsgVk5vZGVQcm92aWRlciB9IGZyb20gJy4uL3JlbmRlci9WTm9kZVByb3ZpZGVyJztcblxuZXhwb3J0IGNsYXNzIFZOb2RlVmlldyBpbXBsZW1lbnRzIFZpZXc8RGlzcGxheVByb3ZpZGVyTm9kZT4ge1xuICAgIHByaXZhdGUgbmFtZTpzdHJpbmc7XG4gICAgcHJpdmF0ZSB2aWV3Q29uc3RydWN0b3I6SGFuZGxlcjxEaXNwbGF5UHJvdmlkZXJOb2RlPjtcbiAgICBwcml2YXRlIGh0bWxQcm92aWRlcjpWTm9kZVByb3ZpZGVyO1xuICAgIHByaXZhdGUgdmlld1Byb3ZpZGVyOkZ1bmN0aW9uO1xuICAgIHByaXZhdGUgYWN0aW9uTG9va3VwOmFueTtcbiAgICBwcml2YXRlIGFjdGlvbkRpc3BhdGNoZXI6QWN0aW9uRGlzcGF0Y2hlcjtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWU6c3RyaW5nLCBoOlZOb2RlUHJvdmlkZXIsIHY6RnVuY3Rpb24sIGE6QWN0aW9uRGlzcGF0Y2hlcikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmh0bWxQcm92aWRlciA9IGg7XG4gICAgICAgIHRoaXMudmlld1Byb3ZpZGVyID0gdjtcbiAgICAgICAgdGhpcy5hY3Rpb25EaXNwYXRjaGVyID0gYTtcbiAgICAgICAgdGhpcy5hY3Rpb25Mb29rdXAgPSBuZXcgTWFwPHN0cmluZywgRnVuY3Rpb24+KCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlZmluZSh2aWV3Q29uc3RydWN0b3I6Vmlld0NvbnN0cnVjdG9yPERpc3BsYXlQcm92aWRlck5vZGU+KTpWaWV3PERpc3BsYXlQcm92aWRlck5vZGU+IHtcbiAgICAgICAgdGhpcy52aWV3Q29uc3RydWN0b3IgPSB2aWV3Q29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIobW9kZWw6TW9kZWwpOkRpc3BsYXlQcm92aWRlck5vZGUge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3Q29uc3RydWN0b3IodGhpcy5odG1sUHJvdmlkZXIsIHRoaXMudmlld1Byb3ZpZGVyLCBtb2RlbC5nZXREYXRhKCksIHRoaXMuYWN0aW9uTG9va3VwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVnaXN0ZXJBY3Rpb25zKC4uLmFjdGlvbk5hbWVzOnN0cmluZ1tdKTpWaWV3PERpc3BsYXlQcm92aWRlck5vZGU+IHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25OYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbk5hbWUgPSBhY3Rpb25OYW1lc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uTG9va3VwW2FjdGlvbk5hbWVdID0gdGhpcy5hY3Rpb25EaXNwYXRjaGVyLmRpc3BhdGNoLmJpbmQoXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25EaXNwYXRjaGVyLCBcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy92aWV3L1ZOb2RlVmlldy50cyIsImltcG9ydCB7IFJlY2VpdmVyIH0gZnJvbSAnLi4vY29yZS9SZWNlaXZlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTW9kZWwgfSBmcm9tICcuLi9jb3JlL01vZGVsLmludGVyZmFjZSc7XG5pbXBvcnQgeyBWaWV3IH0gZnJvbSAnLi4vY29yZS9WaWV3LmludGVyZmFjZSc7XG5pbXBvcnQgeyBBY3Rpb24sIERpc3BsYXlQcm92aWRlck5vZGUgfSBmcm9tICcuLi9jb3JlL2NvcmUudHlwZSdcblxuZXhwb3J0IGNsYXNzIEJhc2VSZWNlaXZlciBpbXBsZW1lbnRzIFJlY2VpdmVyIHtcbiAgICBwcml2YXRlIG5hbWU6c3RyaW5nO1xuICAgIHByaXZhdGUgX21vZGVsTmFtZTpzdHJpbmc7XG4gICAgcHJpdmF0ZSBfdmlld05hbWU6c3RyaW5nO1xuICAgIHByaXZhdGUgX21vZGVsOk1vZGVsO1xuICAgIHByaXZhdGUgX3ZpZXc6VmlldzxEaXNwbGF5UHJvdmlkZXJOb2RlPjtcbiAgICBwcml2YXRlIGFjdGlvblN0YXRlUm91dGVzOmFueTtcbiAgICBwcml2YXRlIGRlcGVuZGVuY2llczogc3RyaW5nW107XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lOnN0cmluZykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KG1vZGVsTG9va3VwOiBNYXA8c3RyaW5nLCBNb2RlbD4sIHZpZXdMb29rdXA6TWFwPHN0cmluZywgVmlldzxEaXNwbGF5UHJvdmlkZXJOb2RlPj4pOnZvaWQge1xuICAgICAgICBsZXQgbTpNb2RlbCA9IG1vZGVsTG9va3VwLmdldCh0aGlzLl9tb2RlbE5hbWUpO1xuICAgICAgICBsZXQgdjpWaWV3PERpc3BsYXlQcm92aWRlck5vZGU+ID0gdmlld0xvb2t1cC5nZXQodGhpcy5fdmlld05hbWUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1vZGVsICR7dGhpcy5fbW9kZWxOYW1lfSBpcyBudWxsYClcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXcgJHt0aGlzLl92aWV3TmFtZX0gaXMgbnVsbGApXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9kZWwgPSBtO1xuICAgICAgICB0aGlzLl92aWV3ID0gdjtcbiAgICB9XG5cbiAgICBwdWJsaWMgbW9kZWwobmFtZTpzdHJpbmcpOlJlY2VpdmVyIHtcbiAgICAgICAgdGhpcy5fbW9kZWxOYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIHZpZXcobmFtZTpzdHJpbmcpOlJlY2VpdmVyIHtcbiAgICAgICAgdGhpcy5fdmlld05hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgYWNjZXB0KHJvdXRlczphbnkpOlJlY2VpdmVyIHtcbiAgICAgICAgdGhpcy5hY3Rpb25TdGF0ZVJvdXRlcyA9IHJvdXRlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIHRyaWdnZXJTdGF0ZUNoYW5nZShhY3Rpb246QWN0aW9uKTp2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX21vZGVsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGVsIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvZXNBY2NlcHRBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbk5hbWUgPSBhY3Rpb25bMF1cbiAgICAgICAgICAgIHRoaXMuX21vZGVsLmhhbmRsZVN0YXRlQ2hhbmdlKHRoaXMuYWN0aW9uU3RhdGVSb3V0ZXNbYWN0aW9uTmFtZV0sIGFjdGlvblsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UmVuZGVyVHJlZSgpOkRpc3BsYXlQcm92aWRlck5vZGUge1xuICAgICAgICBpZiAodGhpcy5fdmlldyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aWV3IGNhbm5vdCBiZSBudWxsXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcucmVuZGVyKHRoaXMuX21vZGVsKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvZXNBY2NlcHRBY3Rpb24oYWN0aW9uOkFjdGlvbik6Ym9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmFjdGlvblN0YXRlUm91dGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFjdGlvbiByb3V0ZXMgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbk5hbWUgPSBhY3Rpb25bMF1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uU3RhdGVSb3V0ZXMuaGFzT3duUHJvcGVydHkoYWN0aW9uTmFtZSk7XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hY3Rpb24vQmFzZVJlY2VpdmVyLnRzIiwiZXhwb3J0IGNsYXNzIEFjdGlvbkRpc3BhdGNoZXIge1xuICAgIHByaXZhdGUgcXVldWVBY3Rpb246RnVuY3Rpb247XG4gICAgcHJpdmF0ZSBsb29rdXA6TWFwPHN0cmluZywgRnVuY3Rpb24+O1xuXG4gICAgY29uc3RydWN0b3IocXVldWVBY3Rpb246RnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5xdWV1ZUFjdGlvbiA9IHF1ZXVlQWN0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgZGlzcGF0Y2goYWN0aW9uTmFtZTpzdHJpbmcsIGU6RXZlbnQpOnZvaWQge1xuICAgICAgICB0aGlzLnF1ZXVlQWN0aW9uKFthY3Rpb25OYW1lLCBlXSk7XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hY3Rpb24vQWN0aW9uRGlzcGF0Y2hlci50cyIsImltcG9ydCB7IFF1ZXVlIH0gZnJvbSAnLi4vY29yZS9RdWV1ZVQuaW50ZXJmYWNlJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL2NvcmUvY29yZS50eXBlJztcblxuZXhwb3J0IGNsYXNzIEFjdGlvblF1ZXVlIGltcGxlbWVudHMgUXVldWU8QWN0aW9uPiB7XG4gICAgcHJpdmF0ZSBtZW1iZXJzOkFjdGlvbltdO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgIH1cblxuICAgIHB1YmxpYyBxdWV1ZShhY3Rpb246QWN0aW9uKTpudW1iZXIge1xuICAgICAgICB0aGlzLm1lbWJlcnMucHVzaChhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1iZXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVxdWV1ZSgpOkFjdGlvbiB7XG4gICAgICAgIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQWN0aW9uIFF1ZXVlIGlzIGVtcHR5JylcbiAgICB9XG5cbiAgICBwdWJsaWMgcGVlaygpOkFjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnNbMF07XG4gICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hY3Rpb24vQWN0aW9uUXVldWUudHMiLCJpbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJy4uL2NvcmUvUmVuZGVyZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IGgsIGNyZWF0ZVByb2plY3RvciwgVk5vZGUsIFByb2plY3RvciB9IGZyb20gJ21hcXVldHRlJztcbmltcG9ydCB7IERpc3BsYXlOb2RlIH0gZnJvbSAnLi4vY29yZS9jb3JlLnR5cGUnO1xuaW1wb3J0IHsgVk5vZGVQcm92aWRlciB9IGZyb20gJy4vVk5vZGVQcm92aWRlcic7XG5cbmV4cG9ydCBjbGFzcyBWTm9kZVJlbmRlcmVyIGltcGxlbWVudHMgUmVuZGVyZXI8Vk5vZGU+IHtcbiAgICBwcml2YXRlIHByb2plY3RvcjpQcm9qZWN0b3I7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvamVjdG9yID0gY3JlYXRlUHJvamVjdG9yKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0aXRjaChyZW5kZXJDaGlsZHJlbjooKSA9PiBWTm9kZVtdKTpWTm9kZSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYuYXBwQ29udGFpbmVyJywge30sIHJlbmRlckNoaWxkcmVuKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBtb3VudChkb21Ob2RlOkRpc3BsYXlOb2RlLCByZW5kZXJGbjooKSA9PiBWTm9kZSk6dm9pZCB7XG4gICAgICAgIHRoaXMucHJvamVjdG9yLmFwcGVuZChkb21Ob2RlLCByZW5kZXJGbik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFZpZXdhYmxlUHJvdmlkZXIoKTpWTm9kZVByb3ZpZGVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZVByb3ZpZGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFZpZXdJbmplY3Rvcihsb29rdXA6TWFwPGFueSwgYW55Pik6KG5hbWU6c3RyaW5nLCBkYXRhOk1hcDxhbnksIGFueT4pID0+IFZOb2RlIHtcbiAgICAgICAgcmV0dXJuIChuYW1lLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IGxvb2t1cC5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LnJlbmRlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL1ZOb2RlUmVuZGVyZXIudHMiLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gJ21hcXVldHRlJztcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAnLi4vY29yZS9Qcm92aWRlclQuaW50ZXJmYWNlJztcblxuZXhwb3J0IGNsYXNzIFZOb2RlUHJvdmlkZXIgaW1wbGVtZW50cyBQcm92aWRlcjxWTm9kZT4ge1xuICAgIGNvbnN0cnVjdG9yKCkge31cblxuICAgIHB1YmxpYyBwcm92aWRlKHNlbGVjdG9yOnN0cmluZywgYXR0cjpNYXA8c3RyaW5nLCBhbnk+LCBjb250ZW50czpWTm9kZVtdKTogVk5vZGUge1xuICAgICAgICByZXR1cm4gaChzZWxlY3RvciwgYXR0ciwgY29udGVudHMpO1xuICAgIH1cbiAgICBwdWJsaWMgdG1sID0gdGhpcy5wcm92aWRlO1xuICAgIHB1YmxpYyBmb3JFYWNoKGRhdGE6YW55W10sIGl0ZXJhdG9yRm46ICgpID0+IFZOb2RlKTogVk5vZGVbXSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoaXRlcmF0b3JGbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBtdXN0IGJlIGl0ZXJhYmxlIHRvIHVzZSBmb3JFYWNoXCIpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL1ZOb2RlUHJvdmlkZXIudHMiXSwic291cmNlUm9vdCI6IiJ9